# -*- coding: utf-8 -*-

from openerp import fields, models, api, _
from openerp.tools import DEFAULT_SERVER_DATETIME_FORMAT, DEFAULT_SERVER_DATE_FORMAT
from openerp.exceptions import except_orm, Warning, RedirectWarning
from lxml import etree, objectify
from pytz import timezone
from openerp import workflow
import sys
from openerp.osv import osv
from itertools import product
import re

reload(sys)
sys.setdefaultencoding("utf-8")

class account_invoice(models.Model):
    _inherit='account.invoice'
    
    detraccion=fields.Boolean('¿Sujeta a detracción?')
    medio_pago=fields.Many2one('tabla.pago.dect','Medio de Pago')
    tipo_operacion_detra=fields.Many2one('tabla.operacion.detra','Tipo Operación Detra')
    redondear_monto_detra = fields.Boolean('Rendondear Total Detraccion')

    #CAMPOS extra para alamacenar momentaneamente los capos de detraccion para
    #los libros electronicos
    fecha_ope_detra=fields.Date('Fecha de Operación de la detracción')
    codigo_ope_detra=fields.Char('Número de la operación de la Detracción')
    
    total_detraccion = fields.Float('Total Detracción',compute='obtener_monto_detraccion',default=0)
    
    account_transfer_id = fields.One2many('account.transfer','account_id','Transferencias')
    
    bien_servicio_detrac=fields.Many2one('tabla.bien.servicio','Bien o Servicio SPOT', 
                    help="En el caso de no Seleccionar Se tomará en cuenta el SPOT de productos o Categorías ")
    
    tasa_detraccion = fields.Float('Tasa de Detracción',compute='obtener_monto_detraccion',default=0.00)
    
    @api.multi
    @api.depends('invoice_line','bien_servicio_detrac', 'redondear_monto_detra')
    def obtener_monto_detraccion(self):
        
        for invoice in self:
            
            #if invoice.detraccion and invoice.amount_total>700:
            if invoice.detraccion:
                 
                if invoice.invoice_line:
                    tasa_detraccion=0.00
                    
                    
                    if invoice.bien_servicio_detrac:
                        tasa_detraccion=invoice.bien_servicio_detrac.porcentaje
                    else:
                        for line in invoice.invoice_line:
                            product = line.product_id.product_tmpl_id
                            if product.bien_servicio_detrac:
                                if tasa_detraccion<product.bien_servicio_detrac.porcentaje:
                                    tasa_detraccion=product.bien_servicio_detrac.porcentaje
                                    
                            else:
                                if product.categ_id.bien_servicio_detrac:
                                    if tasa_detraccion<product.categ_id.bien_servicio_detrac.porcentaje:
                                        tasa_detraccion=product.categ_id.bien_servicio_detrac.porcentaje
                    
                    if invoice.redondear_monto_detra:
                        invoice.total_detraccion = round((invoice.amount_total*tasa_detraccion/100), 0)
                    else:
                        invoice.total_detraccion = round((invoice.amount_total*tasa_detraccion/100), 2)
                    invoice.tasa_detraccion=float(tasa_detraccion)
            
    
    
    @api.multi
    @api.onchange('detraccion')
    def validar_tipo_ope(self):
        
        for invoice in self:
            
            if invoice.detraccion:
                catalogo=self.env['catalogo.51'].search([('id','=',17)])
                invoice.update({'tipo_operacion':catalogo})
            
            else:
                catalogo=self.env['catalogo.51'].search([('id','=',1)])
                invoice.update({'tipo_operacion':catalogo})
    
    
    
    
    

class account_voucher(models.Model):
    
    _inherit="account.voucher"
    
    def button_proforma_voucher(self, cr, uid, ids, context=None):
        
        self.signal_workflow(cr, uid, ids, 'proforma_voucher')
        
        invoice_id = context.get('invoice_id')
        
        invoice = self.pool.get('account.invoice').browse(cr,uid,invoice_id,context=context)
        
        if invoice.detraccion:
            lista = []

            if invoice.company_id.pago_auto_detrac:
                lista.append('out_invoice')
            else:
                lista.append('out_invoice')
                lista.append('in_invoice')

            if invoice.state == "paid" and invoice.type in lista:
                crear_transfer = True
                
                if len(invoice.payment_ids) >=2:
                # for pagos in invoice.payment_ids:
                    # se comento dibido a que si realiza un solo pago que no seea total ya 
                    # no debería generarse transferencias entre cuentas
                    # if pagos.journal_id.detraccion:
                    crear_transfer = False
                
                if crear_transfer:
                    journal_detra = self.pool.get('account.journal').search(cr, uid, [('detraccion','=',True)],context=context)
                    journal_obj = self.pool.get('account.journal').browse(cr,uid,journal_detra,context=context)
                    dict={}
                    
                    if not journal_obj:
                        raise except_orm('Error!',"No se encontro Diario para relacionarlo con el pago de la detracción generada")

                    for journal in journal_obj:
                        if journal.currency:
                            dict['USD']=journal.id
                        else:
                            dict['PEN']=journal.id
                    
                    transfer = {
                            'ref':'Pago Detraccion',
                            'source_journal_id':invoice.payment_ids[0].journal_id.id,
                            'target_journal_id':dict.get(invoice.currency_id.name),
                            'amount':invoice.total_detraccion,
                            'detraccion':True,
                            'account_id':invoice.id,
                        }
                    
                    self.pool.get('account.transfer').create(cr,uid,transfer,context=context)
                
        return {'type': 'ir.actions.act_window_close'}

    
    
    
